<!doctype html>
<html>
  <head>
    <script src="jquery.js"></script>
    <style type="text/css">
      body {
        font-family: monospace;
      }

      .node-passed {
        padding: 8px;
        margin:2px;
        border-radius: 8px;
      }

      .node-possible {
        border-style: solid;
        padding: 8px;
        margin:2px;
        border-radius: 8px;
      }

      .node-possible .key {
        background-color: gray;
        padding: 2px 6px;
        margin: 2px;
        border-radius: 3px;
        font-weight: bold;
      }

      .node-passed .key {
        color: white;
        background-color: black;
        padding: 2px 6px;
        margin: 2px;
        border-radius: 3px;
        font-weight: bold;
      }
    </style>
    <script type="text/javascript">

// returns modifier which adds element at the passed depth
function addElement(elem, depth) {
  return function(urlObj) {
    urlObj.elements[depth] = urlObj.elements[depth] || [];
    urlObj.elements[depth].push(elem);
  }
}

// makes standard node from shortcut passed
function node(shortcut) { 
  var re = /\$([a-zA-Z0-9\/]{1})/g;
  var keys = shortcut.match(re) || [];
  var prefix = "";
  var note = shortcut;

  for (var i = 0; i < keys.length; i++) {
      var k = keys[i].slice(1, 2);
      prefix += k;
      note = note.replace(keys[i], '<span class="key">' + k + '</span>');
  }

  return {
    children: [],
    modifiers: [],
    prefix: prefix,
    possibleElem: $('<span style="border-color: ' + toColor(shortcut) + '" class="node-possible">' + note + '</span>'),
    passedElem: $('<span style="background-color: ' + toColor(shortcut) + '"  class="node-passed">' + note + '</span>'),
    match: function(pattern, position) {    
      return pattern.startsWith(this.prefix, position);
    },    
    child: function(newChild) {
      this.children.push(newChild);
      return this;
    },
    modifier: function(newModifier) {
      this.modifiers.push(newModifier);
      return this;
    },
    traverse: function(pattern, position, depth) {
      var that = this;

      if (pattern.length < position && prefix.length > 0) {
        return parseResult(0, [addElement(that.possibleElem, depth)]);      
      }

      var isMatch = this.match(pattern, position);
      if (!isMatch)
        return null;

      if (this.children.length === 0)
        return parseResult(
          that.prefix.length,
          that.modifiers.concat([addElement(that.passedElem, depth)])
        );

      if (pattern.length <= that.prefix.length + position) {
        var possibleResults = parseResult();
        for (var i = 0; i < that.children.length; ++i) {
          possibleResults = merge(possibleResults, that.children[i].traverse(pattern, position + that.prefix.length + 1, depth + 1));
        }

        return merge(parseResult(
            that.prefix.length,
            that.modifiers.concat([addElement(that.passedElem, depth)])
          ),
        possibleResults);
      }

      for (var i = 0; i < that.children.length; ++i) {
        var result = that.children[i].traverse(pattern, position + that.prefix.length, depth + that.prefix.length > 0 ? 1 : 0);
        if (result !== null)
          return merge(
            parseResult(that.prefix.length, that.modifiers.concat([addElement(that.passedElem, depth)])),
            result
          );
      };

      return null;
    }
  };
}

// returns parsing result
function parseResult(parsed, modifiers) {
  return {
        parsed: parsed || 0,
        modifiers: modifiers || []
      };
}

// Merges two traversing results
function merge(result1, result2) {
  return {
    parsed: result1.parsed + result2.parsed,
    modifiers: result1.modifiers.concat(result2.modifiers)
  };
}

// Combinator node. Calls orBody node and if it returns result goes to thenBody.
function orNode(orBody, thenBody) {
  return {
    traverse: function(pattern, position, depth) {
      var that = this;

      if (pattern.length <= position) {
        return orBody.traverse(pattern, position + 1, depth);
      }

      var orResult = orBody.traverse(pattern, position, depth);
      if (orResult === null)
        return null;

      var thenResult = thenBody.traverse(pattern, position + orResult.parsed, depth + 1);

      if (thenResult === null)
        return null;

      return merge(orResult, thenResult);
    }
  };
}

// Combinator node. Calls andBody node while it returns result or moves towards the pattern and then goes to thenBody
function andNode(andBody, thenBody) {
  return {
    traverse: function(pattern, position, depth) {
      var that = this;
      var andResult = parseResult();
      while (true) {
        result = andBody.traverse(pattern, position + andResult.parsed, depth);
        if (result !== null && result.parsed > 0)
          andResult = merge(andResult, result);
        else
          break;
      }

      var thenResult = thenBody.traverse(pattern, position + andResult.parsed, depth + 1);

      if (thenResult === null)
        return null;

      return merge(andResult, thenResult);
    }
  };
}

// makes freetype node which captures all the input from position to the end of string
function freetype() {
  return {
    children: [],
    modifiers: [],
    match: function(pattern, position) {
      return pattern.substring(position);
    },    
    child: function(newChild) {
      this.children.push(newChild);
      return this;
    },
    modifier: function(newModifier) {
      this.modifiers.push(newModifier);
      return this;
    },
    traverse: function(pattern, position, depth) {
      var that = this;
      var matchText = this.match(pattern, position);

      var mods = that.modifiers.map(function(m) { return function(result) { m(result, matchText); }; });
      
      var freetypeElement = $('<span style="background-color: ' + toColor("freetype") + '" class="node-passed">'+ matchText +'</span>');
      var mods = mods.concat(addElement(freetypeElement, depth));

      return parseResult(matchText.length, mods);
    }
  };
}

// Makes modifier which sets the value for property. If value is not here, it should be passed on calling (required by freetype node)
function set(prop, value) {
  if (value === null)
    return function(obj, value) {
      obj[prop] = value;
    };
  else
    return function(obj) {
      obj[prop] = value;
    };
}

// Makes modifier which replaces substring in property
function replace(prop, from, to) {
  if (to === null)
    return function(obj, to) {
      obj[prop] = obj[prop].replace(from, to);
    };
  else
    return function(obj) {
      obj[prop] = obj[prop].replace(from, to);
    }
}

// Makes modifier to add new element to the property of array type
function add(prop, key, value) {
  if (value === null)
    return function(obj, value) {
      obj[prop] = obj[prop] || [];
      obj[prop].push({k: key, v: value});
    };
  else
    return function(obj) {
      obj[prop] = obj[prop] || [];
      obj[prop].push({k: key, v: value});
    }
}

function buildUrl(obj) {
  var url = obj.host;
  if (obj.path)
    url += "/" + obj.path;
  if (obj.params.length)
    url += "?" + obj.params.map(function(x) { return x.k + "=" + x.v; }).join("&");
  if (obj.anchor && obj.anchor.length)
    url += "#" + obj.anchor;

  return url;
}

function emptyUrl() {
  return {
    host: "",
    path: "",
    params : [],
    anchor: "",
    newWindow: false,
    elements: {}
  };
}

function toColor(s) {
  var res = 0;
  for (var i = 0; i < s.length; ++i) {
    res ^= s.charCodeAt(i);
  };

  return "hsla(" + res % 256 + ", 58%, 70%, 1)";
}

var qnav = {};

function ontype(pattern) {
  var urlObj = emptyUrl();
  var result = root.traverse(pattern, 0, 0);

  if (result !== null) {
    result.modifiers.forEach(function(m) {
      m(urlObj);
    });

    var url = buildUrl(urlObj);
    qnav.url = url;
    qnav.urlObj = urlObj;
    $("#qnav-url").text(url);

    renderElemTree(urlObj.elements);
  } else {
    $("#qnav-url").text("");
  };
 
}

function renderElemTree(elementsObj) {
  $("#tree").text("");
  var i = 1;
  var rowElements;
  while(rowElements = elementsObj[i++]) {
    var row = $('<div class="treeLevel"></div>');
    for (var j = 0; j < rowElements.length; j++) {
      row.append(rowElements[j]);
    };
    $("#tree").append(row);
  }
}

$(function() {
  $('#qnav-input').keypress(function (e) {
     if (e.which === 13 && qnav.url) {
        if (qnav.urlObj.newWindow) {
            var win = window.open(qnav.url, '_blank');
            if (qnav.urlObj.focus)
              win.focus();
        } else {
            document.location.href = qnav.url;
        }

        //window.location.href = qnav.url;
    };
  });
  $("#qnav-input").focus();
  parse();  
  ontype("");
  parserState.source = $('#script').val();
  parserState.position = 0;
  //parse();
});

function parse() {
  parserState.position = 0;
  parserState.source = $('#script').val();

  var rootNode = node("");
  var newNode = parseNode(true);
  rootNode.child(newNode);
  while (newNode = parseNode())
    rootNode.child(newNode);

  root = rootNode;

  //var token;
  //while (token = getToken()) {
  //  console.log(token.type + ' ' + token.value);
  //}
}

var STRING = 0,
  ARROW = 1,
  OPEN_PAREN = 2,
  CLOSE_PAREN = 3,
  OPEN_BRACE = 4,
  CLOSE_BRACE = 5,
  ID = 6,
  TAB = 7,
  UNDERSCORE = 8,
  SEMICOLON = 9,
  COMMA = 10;

function parseNode(start) {  
  var startPosition = getPosition();  
  var currentTab = start ? 0 : tab();

  var str = string();

  if (str) {
    backtrackTo(startPosition);
    return standard(start);
  }

  var identifier = id();

  if (identifier === 'freetype') {
    backtrackTo(startPosition);
    return parseFreeTypeNode(start);
  } else if (identifier === 'or') {
    backtrackTo(startPosition);    
    return parseOrNode(start);
  } else if (identifier === 'and') {
    backtrackTo(startPosition);    
    return parseAndNode(start);
  }

  return null;
}

function standard(start) {
  var currentTab = start ? 0 : tab();

  var shortcut = string();

  if (!shortcut)
    return null;

  var isArrow = arrow();

  var modifiers;
  if (isArrow) {
    modifiers = mods();
  } else {
    modifiers = [];
  }

  var preTabPosition = getPosition();
  var nextTab = tab();
  backtrackTo(preTabPosition);

  var newNode = node(shortcut);

  for (var i = 0; i < modifiers.length; i++) {
    newNode.modifier(modifiers[i]);
  };

  while (nextTab - currentTab === 2) {
    newNode.child(parseNode());
    var preTabPosition = getPosition();
    var nextTab = tab();
    backtrackTo(preTabPosition);
  };

  return newNode;
}

function parseFreeTypeNode(start) {
  var currentTab = start ? 0 : tab();

  var identifier = id();

  if (identifier !== 'freetype')
    return null;

  var isArrow = arrow();

  var modifiers;
  if (isArrow) {
    modifiers = mods();
  } else {
    modifiers = [];
  }

  var newNode = freetype();

  for (var i = 0; i < modifiers.length; i++) {
    newNode.modifier(modifiers[i]);
  };

  var preTabPosition = getPosition();
  var nextTab = tab();
  backtrackTo(preTabPosition);

  while (nextTab - currentTab === 2) {
    newNode.child(parseNode());
    var preTabPosition = getPosition();
    var nextTab = tab();
    backtrackTo(preTabPosition);
  };

  return newNode;
}

function parseOrNode(start) {
  var currentTab = start ? 0 : tab();

  var orId = id();

  if (orId !== 'or')
    return null;

  var orChild = node('');

  var preTabPosition = getPosition();
  var nextTab = tab();
  backtrackTo(preTabPosition);

  while (nextTab - currentTab === 2) {
    orChild.child(parseNode());
    var preTabPosition = getPosition();
    var nextTab = tab();
    backtrackTo(preTabPosition);
  };

  var thenTab = tab();
  var thenId = id();

  if (thenId !== 'then')
    return null;

  var thenChild = node('');

  preTabPosition = getPosition();
  nextTab = tab();
  backtrackTo(preTabPosition);

  while (nextTab - currentTab === 2) {
    thenChild.child(parseNode());
    var preTabPosition = getPosition();
    var nextTab = tab();
    backtrackTo(preTabPosition);
  };

  return orNode(orChild, thenChild);
}

function parseAndNode(start) {
  var currentTab = start ? 0 : tab();

  var andId = id();

  if (andId !== 'and')
    return null;

  var andChild = node('');

  var preTabPosition = getPosition();
  var nextTab = tab();
  backtrackTo(preTabPosition);

  while (nextTab - currentTab === 2) {
    andChild.child(parseNode());
    var preTabPosition = getPosition();
    var nextTab = tab();
    backtrackTo(preTabPosition);
  };

  var thenTab = tab();
  var thenId = id();

  if (thenId !== 'then')
    return null;

  var thenChild = node('');

  preTabPosition = getPosition();
  nextTab = tab();
  backtrackTo(preTabPosition);

  while (nextTab - currentTab === 2) {
    thenChild.child(parseNode());
    var preTabPosition = getPosition();
    var nextTab = tab();
    backtrackTo(preTabPosition);
  };

  return andNode(andChild, thenChild);
}

function mods() {
  var isBrace = openBrace();

  var newModifiers = [];

  if (isBrace) {
    while (true) {
      var newMod = modifier();
      if (!newMod) {
        closeBrace();
        return newModifiers;
      } else {        
        newModifiers.push(newMod);
        semicolon();
      }
    }
  } else {
    return [modifier()];
  }
}

function modifier() {
  var identifier = id();
  if (identifier === null) 
    return null;

  switch (identifier) {
    case 'host':
      openParen();
      var str = string();
      if (!str && underscore())
        str = null;
      closeParen();
      return set('host', str);

    case 'path':
      openParen();
      var str = string();
      if (!str && underscore())
        str = null;
      closeParen();
      return set('path', str);

    case 'anchor':
      openParen();
      var str = string();
      if (!str && underscore())
        str = null;
      closeParen();
      return set('anchor', str);

    case 'param':
      openParen();
      var prop = string();
      comma();
      var value = string();
      if (!value && underscore()) {
        value = null;
      };
      closeParen();
      return add('params', prop, value);

    case 'replace':
      openParen();
      var prop = id();
      comma();
      var fromStr = string();
      comma();
      var toStr = string();
      if (!toStr && underscore())
        var toStr = null;
      closeParen();
      return replace(prop, fromStr, toStr);
  }

  return null;
}

var comma = makeBool(COMMA);
var openParen = makeBool(OPEN_PAREN);
var closeParen = makeBool(CLOSE_PAREN);
var id = makeValue(ID);
var openBrace = makeBool(OPEN_BRACE);
var closeBrace = makeBool(CLOSE_BRACE);
var string = makeValue(STRING);
var arrow = makeBool(ARROW);
var tab = makeValue(TAB);
var underscore = makeBool(UNDERSCORE);
var semicolon = makeBool(SEMICOLON);

function makeBool(type) {
  return function() {
    var startPosition = getPosition();
    var token = getToken();

    if (token.type !== type) {
      backtrackTo(startPosition);
      return false;
    } else {
      return true;
    }
  }
}

function makeValue(type) {
  return function() {
    var startPosition = getPosition();
    var token = getToken();

    if (token === null || token.type !== type) {
      backtrackTo(startPosition);
      return null;
    } else {
      return token.value;
    }
  }
}

var parserState = {};

function getNextChar() {
  return parserState.source[parserState.position++];
}

function backtrack(n) {
  parserState.position = parserState.position - n;
}

function backtrackTo(n) {
  parserState.position = n;
}

function getPosition() {
  return parserState.position;
}

function getToken() {
  var ch;
  do {
    ch = getNextChar();
  } while (ch === ' ' || ch === '\t');

  switch (ch) {
    case '\'':
      var str = '';
      while ((ch = getNextChar()) !== '\'') {
        str += ch;
      }
      return { type: STRING, value: str };

    case '/':
      if (getNextChar() !== '/')
        return null;
      while (getNextChar() !== '\n')
        ;
      backtrack(1);
      return getToken();
    case '\n':
      var tabCount = 0;

      ch = getNextChar();

      while (ch === ' ' || ch === '\t') {
        ++tabCount;
        ch = getNextChar();
      }
      backtrack(1);
      if (ch === '/' || ch === '\n')
          return getToken();

      return { type: TAB, value: tabCount };
    case '-':
      if (getNextChar() === '>')
        return { type: ARROW };
      else
        return null;
      break;

    case '(':
      return { type: OPEN_PAREN };
    case ')':
      return { type: CLOSE_PAREN };
    case '{':
      return { type: OPEN_BRACE };
    case '}':
      return { type: CLOSE_BRACE };
    case '_':
      return { type: UNDERSCORE };
    case ';':
      return { type: SEMICOLON };
    case ',':
      return { type: COMMA };    
  }

  if (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z') {
    var id = '';
    do {
      id += ch;
      ch = getNextChar();
    } while (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z');

    backtrack(1);
    return { type: ID, value: id };
  }

  return null;

}

</script>
  </head>
  <body>
  <input id="qnav-input" type="text" oninput="ontype(this.value)" />
  <div id="qnav-url"></div>
    <div id="defs">
      <textarea id="script" cols="120" rows="30">
'$news'
  '$yandex' -> host('https://news.yandex.ru')
  '$bbc' -> host('https://bbc.com')

// Music
'$music'
  '$groove' -> host('https://groovemp3.com')
    '$artist' -> path('artist/{artist}')
      freetype -> replace(path, '{artist}', _)
  '$vk' -> {host('https://vk.com'); path('audio')}
    freetype -> param('q', _)

'$search'
  'at $google' -> host('https://google.com') 
  'at $yandex' -> host('https://yandex.ru')

// Google Translate
'$t$ranslate' -> {host('https://translate.google.com'); anchor('{from}/{to}/{text}')}
  or
    'from $russian' -> replace(anchor, '{from}', 'ru')
    'from $english' -> replace(anchor, '{from}', 'en')
    'from $spanish' -> replace(anchor, '{from}', 'es')
    'from $german' -> replace(anchor, '{from}', 'de')
  then
    or
      'to $russian' -> replace(anchor, '{to}', 'ru')
      'to $english' -> replace(anchor, '{to}', 'en')
      'to $spanish' -> replace(anchor, '{to}', 'es')
      'to $german' -> replace(anchor, '{to}', 'de')
    then
      freetype -> replace(anchor, '{text}', _)
  freetype -> {replace(anchor, '{from}', 'en'); replace(anchor, '{to}', 'ru'); replace(anchor, '{text}', _)}
      </textarea>

    </div>
    <div id="tree"></div>
  </body>
</html>
