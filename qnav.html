<!doctype html>
<html>
  <head>
    <script   src="https://code.jquery.com/jquery-2.2.4.js"   integrity="sha256-iT6Q9iMJYuQiMWNd9lDyBUStIq/8PuOW33aOqmvFpqI="   crossorigin="anonymous"></script>
    <style type="text/css">
      body {
        font-family: monospace;
      }

      .node-passed {
        padding: 8px;
        border-radius: 8px;
      }

      .node-possible {
        border-style: solid;
        padding: 8px;
        border-radius: 8px;
      }

      .node-possible .key {
        background-color: white;
        padding: 2px 6px;
        margin: 2px;
        border-radius: 3px;
        font-weight: bold;
      }

      .node-passed .key {
        color: white;
        background-color: black;
        padding: 2px 6px;
        margin: 2px;
        border-radius: 3px;
        font-weight: bold;
      }
    </style>
    <script type="text/javascript">

function addElement(elem, depth) {
  return function(urlObj) {
    urlObj.elements[depth] = urlObj.elements[depth] || [];
    urlObj.elements[depth].push(elem);
  }
}

function node(shortcut) { 
  var re = /\$([a-zA-Z0-9\/]{1})/g;
  var keys = shortcut.match(re) || [];
  var prefix = "";
  var note = shortcut;

  for (var i = 0; i < keys.length; i++) {
      var k = keys[i].slice(1, 2);
      prefix += k;
      note = note.replace(keys[i], '<span class="key">' + k + '</span>');
  }

  return {
    children: [],
    modifiers: [],
    prefix: prefix,
    possibleElem: $('<span style="border-color: ' + toColor(shortcut) + '" class="node-possible">' + note + '</span>'),
    passedElem: $('<span style="background-color: ' + toColor(shortcut) + '"  class="node-passed">' + note + '</span>'),
    match: function(pattern, position) {    
      return pattern.startsWith(this.prefix, position);
    },    
    child: function(newChild) {
      this.children.push(newChild);
      return this;
    },
    modifier: function(newModifier) {
      this.modifiers.push(newModifier);
      return this;
    },
    traverse: function(pattern, position, depth) {
      var that = this;

      if (pattern.length < position)
        return parseResult(0, [addElement(that.possibleElem, depth)]);      

      var isMatch = this.match(pattern, position);
      if (!isMatch)
        return null;

      if (this.children.length === 0)
        return parseResult(
          that.prefix.length,
          that.modifiers.concat([addElement(that.passedElem, depth)])
        );

      if (pattern.length === that.prefix.length + position) {
        for (var i = 0; i < that.children.length; ++i) {
          that.children[i].traverse(pattern, position + that.prefix.length + 1, depth );
        }

        return parseResult(
          that.prefix.length,
          that.modifiers.concat([addElement(that.passedElem, depth)])
        );
      }

      for (var i = 0; i < that.children.length; ++i) {
        var result = that.children[i].traverse(pattern, position + that.prefix.length, depth + that.prefix.length > 0 ? 1 : 0);
        if (result !== null)
          return merge(
            parseResult(that.prefix.length, that.modifiers.concat([addElement(that.passedElem, depth)])),
            result
          );
      };

      return null;
    }
  };
}

function parseResult(parsed, modifiers) {
  return {
        parsed: parsed || 0,
        modifiers: modifiers || []
      };
}

// Merges two traversing results
function merge(result1, result2) {
  return {
    parsed: result1.parsed + result2.parsed,
    modifiers: result1.modifiers.concat(result2.modifiers)
  };
}

// Combinator node. Calls orBody node and if it returns result goes to thenBody.
function orNode(orBody, thenBody) {
  return {
    traverse: function(pattern, position, depth) {
      var that = this;

      var orResult = orBody.traverse(pattern, position, depth);
      if (orResult === null)
        return null;

      var thenResult = thenBody.traverse(pattern, position + orResult.parsed, depth + 1);

      if (thenResult === null)
        return null;

      return merge(orResult, thenResult);
    }
  };
}

// Combinator node. Calls andBody node while it returns result or moves towards the pattern and then goes to thenBody
function andNode(andBody, thenBody) {
  return {
    traverse: function(pattern, position, depth) {
      var that = this;
      var andResult = parseResult();
      while (true) {
        result = andBody.traverse(pattern, position + andResult.parsed, depth);
        if (result !== null && result.parsed > 0)
          andResult = merge(andResult, result);
        else
          break;
      }

      var thenResult = thenBody.traverse(pattern, position + andResult.parsed, depth + 1);

      if (thenResult === null)
        return null;

      return merge(andResult, thenResult);
    }
  };
}

function freetype() {
  return {
    children: [],
    modifiers: [],
    match: function(pattern, position) {
      return pattern.substring(position);
    },    
    child: function(newChild) {
      this.children.push(newChild);
      return this;
    },
    modifier: function(newModifier) {
      this.modifiers.push(newModifier);
      return this;
    },
    traverse: function(pattern, position, depth) {
      var that = this;
      var matchText = this.match(pattern, position);

      var newModifiers = that.modifiers.map(function(m) { return function(result) { m(result, matchText); }; });
      
      return parseResult(matchText.length, newModifiers);
    }
  };
}

function set(prop, value) {
  if (value === null)
    return function(obj, value) {
      obj[prop] = value;
    };
  else
    return function(obj) {
      obj[prop] = value;
    };
}

function replace(prop, from, to) {
  if (to === null)
    return function(obj, to) {
      obj[prop] = obj[prop].replace(from, to);
    };
  else
    return function(obj) {
      obj[prop] = obj[prop].replace(from, to);
    }
}

function add(prop, key, value) {
  if (value === null)
    return function(obj, value) {
      obj[prop] = obj[prop] || [];
      obj[prop].push({k: key, v: value});
    };
  else
    return function(obj) {
      obj[prop] = obj[prop] || [];
      obj[prop].push({k: key, v: value});
    }
}

function buildUrl (obj) {
  var url = obj.host;
  if (obj.path)
    url += "/" + obj.path;
  if (obj.params.length)
    url += "?" + obj.params.map(function(x) { return x.k + "=" + x.v; }).join("&");
  if (obj.anchor && obj.anchor.length)
    url += "#" + obj.anchor;

  return url;
}

function emptyUrl() {
  return {
    host: "",
    path: "",
    params : [],
    anchor: [],
    newWindow: false,
    elements: {}
  };
}

function toColor(s) {
  var res = 0;
  for (var i = 0; i < s.length; ++i) {
    res ^= s.charCodeAt(i);
  };

  return "hsla(" + res % 256 + ", 58%, 70%, 1)";
}

var root = andNode(
node("")
  .child(node("new window and focus $/").modifier(set("newWindow", true))),
node("")  
  .child(node("$music")
    .child(node("$groove").modifier(set("host", "http://groovemp3.com"))
      .child(node("$artist").modifier(set("path", "artist/{artist}"))
        .child(freetype().modifier(replace("path", "{artist}", null))))
      .child(node("$search").modifier(set("path", "search/{text}"))
        .child(freetype().modifier(replace("path", "{text}", null)))))      
    .child(node("$v$k").modifier(set("host", "https://vk.com")).modifier(set("path", "search")).modifier(add("params", "c%5Bsection%5D", "audio"))
      .child(freetype().modifier(add("params", "q", null)))))
  .child(node("$search")
    .child(node("at $google").modifier(set("host", "http://google.com")).modifier(set("path", "search"))
      .child(freetype().modifier(add("params", "q", null))))
    .child(node("at yande$x").modifier(set("host", "http://yandex.ru")).modifier(set("path", "search"))
      .child(freetype().modifier(add("params", "text", null))))
    .child(node("at $youtube").modifier(set("host", "https://youtube.com")).modifier(set("path", "results"))
      .child(freetype().modifier(add("params", "search_query", null))))
    .child(node("$vk").modifier(set("host", "https://vk.com")).modifier(set("path", "search")).modifier(add("params", "c%5Bsection%5D", "auto"))
      .child(freetype().modifier(add("params", "c%5Bq%5D", null)))))
  .child(node("$t$ranslate").modifier(set("host", "http://translate.google.com")).modifier(set("anchor", "{from}/{to}/{text}"))
    .child(node("from $russian").modifier(replace("anchor", "{from}", "ru"))
      .child(node("to $english").modifier(replace("anchor", "{to}", "en"))
        .child(freetype().modifier(replace("anchor", "{text}", null)))))
    .child(freetype().modifier(replace("anchor", "{from}", "en")).modifier(replace("anchor", "{to}", "ru")).modifier(replace("anchor", "{text}", null))))
);

var qnav = {};

function ontype(pattern) {
  var urlObj = emptyUrl();
  var result = root.traverse(pattern, 0, 0);

  if (result !== null) {
    result.modifiers.forEach(function(m) {
      m(urlObj);
    });

    var url = buildUrl(urlObj);
    qnav.url = url;
    qnav.urlObj = urlObj;
    $("#qnav-url").text(url);

    renderElemTree(urlObj.elements);
  } else {
    $("#qnav-url").text("");
  };
 
}

function renderElemTree(elementsObj) {
  $("#tree").text("");
  var i = 1;
  var rowElements;
  while(rowElements = elementsObj[i++]) {
    var row = $("<div></div>");
    for (var j = 0; j < rowElements.length; j++) {
      row.append(rowElements[j]);
    };
    $("#tree").append(row);
  }
}

$(function() {
  $('#qnav-input').keypress(function (e) {
     if (e.which === 13 && qnav.url) {
        if (qnav.urlObj.newWindow) {
            var win = window.open(qnav.url, '_blank');
            if (qnav.urlObj.focus)
              win.focus();
        } else {
            document.location.href = qnav.url;
        }

        //window.location.href = qnav.url;
    };
  });
  $("#qnav-input").focus();
});
    </script>
  </head>
  <body>
  <input id="qnav-input" type="text" oninput="ontype(this.value)" />
  <div id="qnav-url"></div>
    <div id="defs">
'$music'
  '$groove' -> host('https://groovemp3.com')
    '$artist' -> path('artist/{artist}')
      freetype -> replace(path, '{artist}', _)
    '$song' ->
  '$v$k' -> 

'$search'
  'at $google' -> host('https://google.com') 
  'at $yandex' -> host('https://yandex.ru')
'$t$ranslate' -> {host('translate.google.com'); anchor('{from}/{to}/{text}')}
  'from $russian' -> replace(anchor, '{from}', 'ru')
    'to $english' -> replace(anchor, '{to}', 'en')

  'from $english' -> replace(anchor, '{from}', 'en')
    </div>
    <div id="tree"></div>
  </body>
</html>